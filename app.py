import dash
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output, State, Event
import pandas as pd
import analysis
import plotly.graph_objs as go
import json
from ast import literal_eval

SUBSET_METRICS = [
    {'label': 'perfectly_chosen', 'value': 'perfectly_chosen'},
    {'label': 'predictors_missed', 'value': 'predictors_missed'},
    {'label': 'false_predictors_chosen', 'value': 'false_predictors_chosen'},
    {'label': 'symm_diff', 'value': 'symm_diff'},
    {'label': 'symm_diff_2', 'value': 'symm_diff_2'},
]
ERROR_TYPES = [
    {'label': 'Prediction MSE', 'value': 'prediction_mse'},
    {'label': 'Prediction Mean Error', 'value': 'prediction_me'},
]

data = pd.read_csv("data.csv")
app = dash.Dash()

app.scripts.config.serve_locally = True    
# Some ids are generated by callbacks, and are not in the initial layout, so they throw errors
app.config['suppress_callback_exceptions']=True

app.layout = \
    html.Div([
        dcc.Tabs(tabs=[
                {'label': 'Data', 'value': 1},
                {'label': 'Experiment', 'value': 2}], 
            value=2, vertical=False, id='tabs'
        ),
        # Data tab
        html.Div([
            ], className="page", style={'display':'none'}, id='data-tab'),
        # Experiment tab
        html.Div([
            html.Div([
                html.Div([
                        html.H6('Variable Selection', className='gs-header gs-table-header tiny-header'),
                        dcc.Graph(id='variable-selection-graph')                          
                        ], className="eight columns"),
                html.Div([
                            html.H6('Variable Selection Method', className='gs-header gs-table-header tiny-header'),
                            dcc.Dropdown(
                                options=[
                                    {'label': 'Lasso CV', 'value': 'LassoCV'},
                                    {'label': 'Lasso CV + 1 std.', 'value': 'LassoCVStd'},
                                    {'label': 'Lasso BIC', 'value': 'LassoBIC'},
                                ],
                                multi=True,
                                placeholder="Select a variable selection method",
                                id="variable-selection-methods"
                            ),
                            dcc.Dropdown(
                                options=SUBSET_METRICS,
                                multi=True,
                                placeholder="Select a variable selection metric",
                                id="variable-selection-metrics"
                            )
                        ], className="four columns")
            ], 
            className="row"),
            html.Div([
                html.Div([
                        html.H6('Prediction Error', className='gs-header gs-table-header tiny-header'),
                        dcc.Graph(id='prediction-error-graph')     
                        ], className="eight columns"),
                html.Div([
                            html.H6('Error Types', className='gs-header gs-table-header tiny-header'),
                            dcc.Dropdown(
                                options=ERROR_TYPES,
                                multi=True,
                                placeholder="Select a prediction metric",
                                id="error-types"
                            )
                        ], className="four columns")
            ], 
            className="row"),
            html.Div([
                    html.Div([
                        html.H6('# Trials', className='gs-header gs-table-header tiny-header'),
                        dcc.Input(
                            id='num-trials',
                            placeholder='Enter a value...',
                            type='number',
                            inputmode='numeric',
                            min='1',
                            value='5'
                        ),
                    ], className="two columns"),
                    html.Div([
                        html.H6('# Samples Min', className='gs-header gs-table-header tiny-header'),
                        dcc.Input(
                            id='samples-min',
                            placeholder='Enter a value...',
                            type='number',
                            inputmode='numeric',
                            min='5',
                            value='5'
                        ),
                    ], className="two columns"),
                    html.Div([
                        html.H6('# Samples Max', className='gs-header gs-table-header tiny-header'),
                        dcc.Input(
                            id='samples-max',
                            placeholder='Enter a value...',
                            type='number',
                            inputmode='numeric',
                            min='0',
                            value='11'
                        ),
                    ], className="two columns"),
                    html.Div([
                        html.H6('# Samples Step', className='gs-header gs-table-header tiny-header'),
                        dcc.Input(
                            id='samples-step',
                            placeholder='Enter a value...',
                            type='number',
                            inputmode='numeric',
                            min='0',
                            value='5'
                        ),
                    ], className="two columns"),
                    html.Div([
                        html.Button('Run Experiment', id='run-button', className='button-primary')
                    ], className='four columns',style={'float':'right','vertical-align':'bottom'})
                ], className='row'),
        ], className='page', style={'display':'none'}, id='experiment-tab'),
        # Hidden div inside the app that stores the intermediate value
        html.Div(id='graph-data-df', style={'display': 'none'}),
        
    ], style={
        'width': '80%',
        'fontFamily': 'Sans-Serif',
        'margin-left': 'auto',
        'margin-right': 'auto'
        }
    )


@app.callback(Output('data-tab', 'style'), [Input('tabs', 'value')])
def display_data_content(tabid):
    return {'display': 'block' if tabid == 1 else 'none'}
@app.callback(Output('experiment-tab', 'style'), [Input('tabs', 'value')])
def display_experiment_content(tabid):
    return {'display': 'block' if tabid == 2 else 'none'}


@app.callback(Output('graph-data-df', 'children'),
              [],
              [State('num-trials', 'value'),
               State('samples-min', 'value'), 
               State('samples-max', 'value'), 
               State('samples-step','value'),
               State('variable-selection-metrics', 'value'),
               State('variable-selection-methods', 'value'),
               State('error-types', 'value')],
              [Event('run-button', 'click')])
def update_graph_data(trials, samples_min, samples_max, samples_step, subset_metrics, subset_methods, error_types):
    if None in [trials, samples_min, samples_max, samples_step, subset_metrics, subset_methods, error_types]:
        return pd.DataFrame().to_json()
    sample_range = range(int(samples_min), int(samples_max), int(samples_step))
    df = analysis.subset_accuracy(data, sample_range, int(trials), subset_metrics, subset_methods, error_types)
    print(df)
    # convert dataframe to nested dictionary
    df_dict = df.groupby(level=0).apply(lambda df: df.xs(df.name).to_dict()).to_dict()
    # convert tuple keys to strings
    df_dict = {str(i) : {str(key) : inner_val for key,inner_val in val.items()} for i,val in df_dict.items()}
    # convert to json
    json_str = json.dumps(df_dict)
    return json_str


def load_graph_data(cached_df):
    # load json
    df_dict = json.loads(cached_df)
    def eval_tuple(strobj):
        if strobj.startswith('('):
            return literal_eval(strobj)
        return strobj
    # convert tuple strings to python tuples
    df_dict = {int(i): {eval_tuple(t) : val for t,val in v.items()} for i, v in df_dict.items()}
    # flip rows and columns and convert to dataframe
    df = pd.DataFrame.from_dict(df_dict).T
    return df

@app.callback(Output('prediction-error-graph', 'figure'),
              [Input('graph-data-df', 'children')])
def prediction_error_update_graph(cached_df):
    if cached_df == None:
        return {'data':[]}
    df = load_graph_data(cached_df)
    error_type_values = [s['value'] for s in ERROR_TYPES]
    plot_data = []
    for (subset_method, subset_metric) in [col for col in df.columns if col[1] in error_type_values]:
        fig = go.Scatter(
                x=df['sample_size'].values,
                y=df[(subset_method, subset_metric)].values,
                mode='lines+markers',
                marker={'size':8},
                name="%s: %s" % (subset_method, subset_metric)
               )
        plot_data.append(fig)
    return {'data':plot_data, 
            'layout': go.Layout(
                xaxis={'title': 'Number of samples'},
                yaxis={'title': '%'},
                #hovermode='closest'
            )}

@app.callback(Output('variable-selection-graph', 'figure'),
              [Input('graph-data-df', 'children')])
def variable_selection_update_graph(cached_df):
    if cached_df == None:
        return {'data':[]}
    df = load_graph_data(cached_df)
    plot_data = []
    subset_metric_values = [s['value'] for s in SUBSET_METRICS]
    for (subset_method, subset_metric) in [col for col in df.columns if col[1] in subset_metric_values]:
        fig = go.Scatter(
                x=df['sample_size'].values,
                y=df[(subset_method, subset_metric)].values,
                mode='lines+markers',
                marker={'size':8},
                name="%s: %s" % (subset_method, subset_metric)
               )
        plot_data.append(fig)
    return {'data':plot_data, 
            'layout': go.Layout(
                xaxis={'title': 'Number of samples'},
                yaxis={'title': '%'},
                #hovermode='closest'
            )}

if __name__ == '__main__':
    app.css.append_css({'external_url': 'https://codepen.io/chriddyp/pen/bWLwgP.css'})
    app.run_server(debug=True)